//#define _CRT_SECURE_NO_WARNINGS 1
//#include <iostream>
//using namespace std;
//
//// 为了取代c语言的宏函数，并且可以再类内使用
//// c++用内联函数来代替
//#define ADD(x, y) x+y //宏
//inline int Add(int x, int y) // 内联函数 
//{
//    return x + y;
//}
//
//// 保证了参数的完整性，但是下面的代码依然有问题
//// 无法避免++带来的“缺陷”
//#define COMPARE(x, y) ((x) < (y) ? (x) : (y)) 
//inline int Compare(int x, int y)
//{
//    return x < y ? x : y;
//}
//
//// 内联函数的本质是一个真正的函数
//// 所以可以进行参数的检查
//// 在适当的时候会像宏一样展开
//// 在c++中应使用内联函数取代宏
//// 声明和定义应写在一起，否则就不会被认为是内联函数
//// 内联函数会开辟空间（具有实际参数）但没有入栈和出栈的开销
//// 所以可以认为是用空间换时间的做法
//// 在类内定义的成员函数会自动转换成内联函数
//// 内联函数的替换是在编译阶段，没有发现错误时会将内联函数放入符号表
//// 
//// 以下不会被编译器认为是内联函数
//// 1 过多的判断
//// 2 任何形式的循环
//// 3 不能过于庞大
//// 4 不能取地址
//// 
//// 实际上内联是给编译器的建议，编译器不一定接受
//// 和寄存器变量类似
//// 
//
//void test1()
//{
//    int ret1 = ADD(10, 20) * 10; // 预期300
//    int ret2 = Add(10, 20) * 10; // 预期300
//    cout << ret1 << endl; // 实际210
//    cout << ret2 << endl; // 实际300
//
//    int a = 1;
//    int b = 3;
//    // cout << "min = " << COMPARE(++a, b) << endl; // a加了两次
//    cout << "min = " << Compare(++a, b) << endl; // a只加一次
//}
//
//int main() 
//{
//    test1();
//    return 0;
//}
