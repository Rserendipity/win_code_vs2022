#define _CRT_SECURE_NO_WARNINGS 1
#include <iostream>
using namespace std;
class Data {
public:
    int num;
    
    // 无参构造
    Data()
    {
        num = 0;
        cout << "无参构造 num的值是"<< num << endl;
    }
    // 有参构造
    Data(int n)
    {
        num = n;
        cout << "有参构造 num的值是" << num << endl;
    }
    // 拷贝构造
    Data(const Data& d)
    {
        // 不对类成员进行拷贝时，类成员是随机值
        // 所以要自己写好对象的拷贝
        // 

        // 手动写了拷贝构造并赋值
        num = d.num;
        cout << "拷贝构造函数的调用"  << endl;
    }
    // 析构函数 没有返回值，没有参数，不能重载
    ~Data()
    {
        cout << "析构调用 num的值是" << num << endl;
    }
};

void test1()
{
    // 局部变量
    // 没有传入参数，所以会调用无参构造
    // 函数结束时局部对象被销毁
    // 自动调用析构函数
    // 在同一个作用域下，析构函数的调用是栈的关系
    // 即先被构造的，后被析构
    // 
    Data d1; // 无参构造 或者 默认构造   隐式的调用
    Data d2 = Data(); // 无参构造    显式调用无参构造
    
    Data d3(10); // 有参构造  隐式调用
    Data d4 = Data(20); // 有参构造  显式调用

    // 隐式转换，仅针对一个成员的类
    Data d5 = 30; //会转换成  Data d5(30);

    // 匿名对象（当前语句结束，匿名对象立即释放）
    cout << "-------匿名构造------" << endl;
    Data(40); // 用于拷贝构造
    cout << "-------匿名析构------" << endl;

}

void test2()
{
    // 不写拷贝构造函数系统会自己提供一个
    // 但是自动的构造是直接赋值操作
    // 如果用户写了自己的拷贝构造，那就会调用自己实现的拷贝构造
    // 
    // 用旧的对象初始化一个新的对象，就会调用拷贝构造
    // 只有在定义（初始化）的时候才是新的对象，否则都是就对象
    // 
    Data d1(10); // 隐式有参构造
    Data d2(d1); // 隐式拷贝构造
    Data d3 = Data(d1); // 显式拷贝构造
    Data d4 = d1; // 隐式转换的拷贝构造，会转换成上面的形式
}

void test3()
{
    Data d1(10);// 调用了隐式的有参构造
    Data d2;   // 已经调用了隐式无参构造
    d2 = d1;   // 单纯的赋值操作（没有运算符重载时）
}

// 
// 构造函数：执行类的初始化
// 构造函数名和类名相同，没返回值，可以有参数，可以重载
// 
// 析构函数：执行类的销毁
// 析构函数名是~类名，没有返回值，没有参数，不可以重载
// 
// 构造函数的分类：参数方面   ----  无参/有参
//                类型分类   ----  普通构造/拷贝构造
// 
int main() 
{
    //cout << "-------1------" << endl;
    //test1();
    //cout << "-------2------" << endl;
    //cout << "-------1------" << endl;
    //test2();
    //cout << "-------2------" << endl;
    cout << "-------1------" << endl;
    test3();
    cout << "-------2------" << endl;

    return 0;
}
